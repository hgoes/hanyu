package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"sort"
	"strings"
	"unicode"
)

func main() {
	f, err := os.Open("sounds.txt")
	if err != nil {
		panic(err)
	}
	h, err := os.Create("gen.go")
	if err != nil {
		panic(err)
	}
	var sounds []string
	sc := bufio.NewScanner(f)
	for sc.Scan() {
		ln := sc.Text()
		if strings.HasPrefix(ln, "#") {
			continue
		}
		sounds = append(sounds, ln)
	}
	if err := sc.Err(); err != nil {
		panic(err)
	}
	var tree node
	for _, sound := range sounds {
		tree.insert([]rune(sound))
	}
	fmt.Fprintf(h,
		"// Code generated by gen-pinyin-parser; DO NOT EDIT.\n"+
			"package pinyin\n\n"+
			"const (\n"+
			"\tstart parserState = iota\n")
	tree.subwords(nil, func(st string) {
		fmt.Fprintf(h, "\tst%s\n", st)
	})
	fmt.Fprintf(h, ")\n\n"+
		"const (\n")
	for i, sound := range sounds {
		fmt.Fprintf(h, "\t%s", strings.ToUpper(sound))
		if i == 0 {
			fmt.Fprintf(h, " Sound = iota")
		}
		fmt.Fprintf(h, "\n")
	}
	fmt.Fprintf(h,
		")\n\nfunc (p Sound) String() string {\n"+
			"\tswitch p {\n")
	for _, sound := range sounds {
		fmt.Fprintf(h,
			"\tcase %s:\n"+
				"\t\treturn %q\n",
			strings.ToUpper(sound), sound)
	}
	fmt.Fprintf(h,
		"\tdefault:\n"+
			"\t\treturn \"?\"\n"+
			"\t}\n"+
			"}\n\n"+
			"func (p parserState) Sound() (bool, Sound) {\n"+
			"\tswitch p {\n")
	for _, sound := range sounds {
		upper := strings.ToUpper(sound)
		fmt.Fprintf(h,
			"\tcase st%s:\n"+
				"\t\treturn true, %s\n",
			upper, upper)
	}
	fmt.Fprintf(h,
		"\tdefault:\n"+
			"\t\treturn false, 0\n"+
			"\t}\n"+
			"}\n\n"+
			"func (p parserState) next(r rune) (bool, parserState) {\n"+
			"\tswitch p {\n")
	tree.transitions(h, nil, false)
	fmt.Fprintf(h, "\t}\n"+
		"\treturn false, 0\n"+
		"}\n\n"+
		"func (p Sound) special() bool {\n"+
		"\tswitch p {\n")
	for _, sound := range sounds {
		switch sound[0] {
		case 'a', 'e', 'o':
			fmt.Fprintf(h, "\tcase %s:\n"+
				"\t\treturn true\n",
				strings.ToUpper(sound))
		}
	}
	fmt.Fprintf(h, "\tdefault:\n"+
		"\t\treturn false\n"+
		"\t}\n"+
		"}\n")
	h.Close()
}

type node struct {
	Next []nodeNext
}

type nodeNext struct {
	Rune rune
	Node *node
}

func (n *node) insert(word []rune) {
	if len(word) == 0 {
		return
	}
	var nxt *node
	idx := sort.Search(len(n.Next), func(i int) bool {
		return n.Next[i].Rune >= word[0]
	})
	if idx >= len(n.Next) {
		nxt = &node{}
		n.Next = append(n.Next, nodeNext{
			Rune: word[0],
			Node: nxt,
		})
	} else if n.Next[idx].Rune == word[0] {
		nxt = n.Next[idx].Node
	} else {
		n.Next = append(n.Next, nodeNext{})
		copy(n.Next[idx+1:], n.Next[idx:len(n.Next)-1])
		n.Next[idx].Rune = word[0]
		nxt = &node{}
		n.Next[idx].Node = nxt
	}
	nxt.insert(word[1:])
}

func (n *node) subwords(cur []rune, f func(string)) []rune {
	sz := len(cur)
	cur = append(cur, ' ')
	hasU := false
	for _, next := range n.Next {
		cur[sz] = unicode.ToUpper(next.Rune)
		f(string(cur))
		cur = next.Node.subwords(cur, f)
		switch next.Rune {
		case 'u':
			hasU = true
		case 'ü':
			if !hasU {
				cur[sz] = 'U'
				f(string(cur))
			}
		}
	}
	return cur[:sz]
}

func (n *node) transitions(wr io.Writer, cur []rune, specialU bool) []rune {
	if len(n.Next) == 0 {
		return cur
	}
	var name string
	if len(cur) == 0 {
		name = "start"
	} else {
		name = fmt.Sprintf("st%s", string(cur))
	}
	fmt.Fprintf(wr,
		"\tcase %s:\n"+
			"\t\tswitch r {\n",
		name)
	if len(cur) == 0 {
		fmt.Fprintf(wr,
			"\t\tcase ' ':\n"+
				"\t\t\treturn true, start\n")
	}
	sz := len(cur)
	cur = append(cur, ' ')
	hasU := false
	hasÜ := false
	for _, next := range n.Next {
		cur[sz] = unicode.ToUpper(next.Rune)
		fmt.Fprintf(wr,
			"\t\tcase %q:\n"+
				"\t\t\treturn true, st%s\n",
			next.Rune, string(cur))
		switch next.Rune {
		case 'u':
			hasU = true
		case 'ü':
			hasÜ = true
			if !hasU {
				cur[sz] = 'U'
				fmt.Fprintf(wr,
					"\t\tcase 'u':\n"+
						"\t\t\treturn true, st%s\n",
					string(cur))
			}
		}
	}
	if specialU {
		cur[sz-1] = 'Ü'
		fmt.Fprintf(wr,
			"\t\tcase ':':\n"+
				"\t\t\treturn true, st%s\n",
			string(cur[:sz]))
		cur[sz-1] = 'U'
	}
	fmt.Fprintf(wr, "\t\t}\n")
	for _, next := range n.Next {
		cur[sz] = unicode.ToUpper(next.Rune)
		cur = next.Node.transitions(wr, cur, next.Rune == 'u' && hasÜ)
	}
	return cur[:sz]
}
